{"version":3,"sources":["webpack://PhaserMatterCollisionPlugin/webpack/universalModuleDefinition","webpack://PhaserMatterCollisionPlugin/external {\"root\":\"Phaser\",\"commonjs\":\"phaser\",\"commonjs2\":\"phaser\",\"amd\":\"phaser\"}","webpack://PhaserMatterCollisionPlugin/webpack/bootstrap","webpack://PhaserMatterCollisionPlugin/webpack/runtime/define property getters","webpack://PhaserMatterCollisionPlugin/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserMatterCollisionPlugin/webpack/runtime/make namespace object","webpack://PhaserMatterCollisionPlugin/./logger.ts","webpack://PhaserMatterCollisionPlugin/./utils.ts","webpack://PhaserMatterCollisionPlugin/./valid-collision-object.ts","webpack://PhaserMatterCollisionPlugin/./phaser-matter-collision-plugin.ts","webpack://PhaserMatterCollisionPlugin/./index.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__445__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","log","console","warn","error","getRootBody","body","parent","warnInvalidObject","logger","Tile","Tilemaps","isMatterBody","isCollidingObject","Matter","Physics","START","DESTROY","SHUTDOWN","Scenes","COLLISION_START","COLLISION_ACTIVE","COLLISION_END","Events","MatterCollisionPlugin","Plugins","constructor","scene","pluginManager","pluginKey","super","events","collisionStartListeners","Map","collisionEndListeners","collisionActiveListeners","once","start","destroy","addOnCollideStart","config","addOnCollide","removeOnCollide","addOnCollideEnd","addOnCollideActive","removeOnCollideStart","removeOnCollideEnd","removeOnCollideActive","removeAllCollideStartListeners","clear","removeAllCollideActiveListeners","removeAllCollideEndListeners","removeAllCollideListeners","map","context","callback","objectA","objectB","objectsA","Array","isArray","objectsB","forEach","a","b","addOnCollideObjectVsObject","remainingCallbacks","filter","cb","includes","target","length","set","delete","callbacks","push","onCollisionStart","event","onCollisionEvent","onCollisionEnd","onCollisionActive","listenerMap","eventName","pairs","pairEventName","eventData","isReversed","eventDataReversed","pair","i","bodyA","bodyB","rootBodyA","rootBodyB","gameObjectA","gameObject","gameObjectB","TileBody","tile","emit","size","data","dataReversed","checkPairAndEmit","subscribeMatterEvents","matter","world","on","unsubscribeMatterEvents","off","shutdown"],"mappings":"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","file":"phaser-matter-collision.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"phaser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"phaser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserMatterCollisionPlugin\"] = factory(require(\"phaser\"));\n\telse\n\t\troot[\"PhaserMatterCollisionPlugin\"] = factory(root[\"Phaser\"]);\n})((typeof self !== \"undefined\" ? self : this), function(__WEBPACK_EXTERNAL_MODULE__445__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__445__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default {\r\n  log: console.log,\r\n  warn: console.warn,\r\n  error: console.error,\r\n};\r\n","import logger from \"./logger\";\r\n\r\n/**\r\n * Get the root body of a compound Matter body.\r\n */\r\nexport function getRootBody(body: MatterJS.BodyType) {\r\n  while (body.parent !== body) body = body.parent;\r\n  return body;\r\n}\r\n\r\n/**\r\n * @param obj\r\n */\r\nexport function warnInvalidObject(obj: any) {\r\n  logger.warn(\r\n    `Expected a Matter body, a Tile, a GameObject, a Sprite, an Image, a TileBody, or an object with a body property, but instead, received: ${obj}`\r\n  );\r\n}\r\n","import { Tilemaps, Types } from \"phaser\";\r\n\r\nimport Tile = Tilemaps.Tile;\r\nimport MatterBody = Types.Physics.Matter.MatterBody;\r\n\r\n/** A valid physics-enabled game object, or just an object that has \"body\" property */\r\nexport type ObjectWithBody = {\r\n  body: MatterJS.BodyType;\r\n};\r\n\r\n/**\r\n * A union of all the types of physics objects we could have in the simulation - from raw Matter.js\r\n * bodies to tiles and physics-enabled Phaser GameObjects.\r\n */\r\nexport type CollidingObject = MatterBody | MatterJS.BodyType | Tile | ObjectWithBody;\r\n\r\n/** Duck type to check if the given object is a Matter body (because there isn't a prototype). */\r\nexport function isMatterBody(obj: any): obj is MatterBody {\r\n  return (\r\n    obj.hasOwnProperty(\"parts\") && obj.hasOwnProperty(\"slop\") && obj.hasOwnProperty(\"gameObject\")\r\n  );\r\n}\r\n\r\n/**\r\n * Check if object is an acceptable physical object for this plugin - a Matter Body, a tile, or an\r\n * object with a body property.\r\n */\r\nexport function isCollidingObject(obj: any): obj is CollidingObject {\r\n  // GameObjects, images, sprites and tile bodies should all have a body property.\r\n  return isMatterBody(obj) || obj.body || obj instanceof Tile;\r\n}\r\n","import { Physics, Plugins, Scene, Events, Scenes, Tilemaps } from \"phaser\";\r\nimport { getRootBody, warnInvalidObject } from \"./utils\";\r\nimport logger from \"./logger\";\r\nimport { CollidingObject as CO, isCollidingObject } from \"./valid-collision-object\";\r\nimport {\r\n  ListenerMap,\r\n  CollideABConfig as ABConfig,\r\n  Unsubscribe,\r\n  CollideCallback,\r\n  CollideContext,\r\n  ExtendedMatterCollisionData,\r\n  EventData,\r\n  CollideAConfig as AConfig,\r\n  InternalCollideConfig,\r\n  RemoveCollideConfigA as RemoveAConfig,\r\n  RemoveCollideConfigAB as RemoveABConfig,\r\n  InternalCollideRemoveConfig,\r\n} from \"./collision-types\";\r\n\r\nimport Matter = Physics.Matter;\r\nimport MatterEvents = Matter.Events;\r\nconst { START, DESTROY, SHUTDOWN } = Scenes.Events;\r\nconst { COLLISION_START, COLLISION_ACTIVE, COLLISION_END } = Matter.Events;\r\n\r\ntype MatterCollisionEvent =\r\n  | MatterEvents.CollisionActiveEvent\r\n  | MatterEvents.CollisionEndEvent\r\n  | MatterEvents.CollisionActiveEvent;\r\n\r\n/**\r\n * @export\r\n */\r\nexport default class MatterCollisionPlugin extends Plugins.ScenePlugin {\r\n  public events = new Events.EventEmitter();\r\n\r\n  private collisionStartListeners: ListenerMap = new Map();\r\n  private collisionEndListeners: ListenerMap = new Map();\r\n  private collisionActiveListeners: ListenerMap = new Map();\r\n\r\n  constructor(\r\n    protected scene: Scene,\r\n    protected pluginManager: Plugins.PluginManager,\r\n    pluginKey: string\r\n  ) {\r\n    super(scene, pluginManager, pluginKey);\r\n    this.scene = scene;\r\n    this.scene.events.once(START, this.start, this);\r\n    this.scene.events.once(DESTROY, this.destroy, this);\r\n  }\r\n\r\n  /**\r\n   * Add a listener for collidestart events between objectA and objectB. The collidestart event is\r\n   * fired by Matter when two bodies start colliding within a tick of the engine. If objectB is\r\n   * omitted, any collisions with objectA will be passed along to the listener. See\r\n   * {@link paircollisionstart} for information on callback parameters.\r\n   */\r\n  public addOnCollideStart<T extends CO, K extends CO>(config: ABConfig<T, K>): Unsubscribe;\r\n  public addOnCollideStart<T extends CO>(config: AConfig<T>): Unsubscribe;\r\n  public addOnCollideStart(config: InternalCollideConfig): Unsubscribe {\r\n    // Note: the order of overloads is important! TS matches the first one it can, so this needs\r\n    // the most specific/constrained signature first.\r\n    this.addOnCollide(this.collisionStartListeners, config);\r\n    return () => this.removeOnCollide(this.collisionStartListeners, config);\r\n  }\r\n\r\n  /** This method mirrors {@link MatterCollisionPlugin#addOnCollideStart} */\r\n  public addOnCollideEnd<T extends CO, K extends CO>(config: ABConfig<T, K>): Unsubscribe;\r\n  public addOnCollideEnd<T extends CO>(config: AConfig<T>): Unsubscribe;\r\n  public addOnCollideEnd(config: InternalCollideConfig): Unsubscribe {\r\n    this.addOnCollide(this.collisionEndListeners, config);\r\n    return () => this.removeOnCollide(this.collisionEndListeners, config);\r\n  }\r\n\r\n  /** This method mirrors {@link MatterCollisionPlugin#addOnCollideStart} */\r\n  public addOnCollideActive<T extends CO, K extends CO>(config: ABConfig<T, K>): Unsubscribe;\r\n  public addOnCollideActive<T extends CO>(config: AConfig<T>): Unsubscribe;\r\n  public addOnCollideActive(config: InternalCollideConfig): Unsubscribe {\r\n    this.addOnCollide(this.collisionActiveListeners, config);\r\n    return () => this.removeOnCollide(this.collisionActiveListeners, config);\r\n  }\r\n\r\n  /**\r\n   * Remove any listeners that were added with addOnCollideStart. If objectB, callback or context\r\n   * parameters are omitted, any listener matching the remaining parameters will be removed. E.g. if\r\n   * you only specify objectA and objectB, all listeners with objectA & objectB will be removed\r\n   * regardless of the callback or context.\r\n   */\r\n  public removeOnCollideStart<T extends CO, K extends CO>(config: RemoveABConfig<T, K>): void;\r\n  public removeOnCollideStart<T extends CO>(config: RemoveAConfig<T>): void;\r\n  public removeOnCollideStart(config: InternalCollideRemoveConfig) {\r\n    this.removeOnCollide(this.collisionStartListeners, config);\r\n  }\r\n\r\n  /** This method mirrors {@link MatterCollisionPlugin#removeOnCollideStart} */\r\n  public removeOnCollideEnd<T extends CO, K extends CO>(config: RemoveABConfig<T, K>): void;\r\n  public removeOnCollideEnd<T extends CO>(config: RemoveAConfig<T>): void;\r\n  public removeOnCollideEnd(config: InternalCollideRemoveConfig) {\r\n    this.removeOnCollide(this.collisionEndListeners, config);\r\n  }\r\n\r\n  /** This method mirrors {@link MatterCollisionPlugin#removeOnCollideStart} */\r\n  public removeOnCollideActive<T extends CO, K extends CO>(config: RemoveABConfig<T, K>): void;\r\n  public removeOnCollideActive<T extends CO>(config: RemoveAConfig<T>): void;\r\n  public removeOnCollideActive(config: InternalCollideRemoveConfig) {\r\n    this.removeOnCollide(this.collisionActiveListeners, config);\r\n  }\r\n\r\n  /** Remove any listeners that were added with addOnCollideStart. */\r\n  public removeAllCollideStartListeners() {\r\n    this.collisionStartListeners.clear();\r\n  }\r\n\r\n  /** Remove any listeners that were added with addOnCollideActive. */\r\n  public removeAllCollideActiveListeners() {\r\n    this.collisionActiveListeners.clear();\r\n  }\r\n\r\n  /** Remove any listeners that were added with addOnCollideEnd. */\r\n  public removeAllCollideEndListeners() {\r\n    this.collisionEndListeners.clear();\r\n  }\r\n\r\n  /**\r\n   * Remove any listeners that were added with addOnCollideStart, addOnCollideActive or\r\n   * addOnCollideEnd.\r\n   */\r\n  public removeAllCollideListeners() {\r\n    this.removeAllCollideStartListeners();\r\n    this.removeAllCollideActiveListeners();\r\n    this.removeAllCollideEndListeners();\r\n  }\r\n\r\n  private addOnCollide(map: ListenerMap, config: InternalCollideConfig): void {\r\n    const { context, callback, objectA, objectB } = config;\r\n    if (!callback || typeof callback !== \"function\") {\r\n      logger.warn(`No valid callback specified. Received: ${callback}`);\r\n      return;\r\n    }\r\n    const objectsA = Array.isArray(objectA) ? objectA : [objectA];\r\n    const objectsB = Array.isArray(objectB) ? objectB : [objectB];\r\n    objectsA.forEach((a) => {\r\n      objectsB.forEach((b) => {\r\n        this.addOnCollideObjectVsObject(map, a, b, callback, context);\r\n      });\r\n    });\r\n  }\r\n\r\n  private removeOnCollide(map: ListenerMap, config: InternalCollideRemoveConfig) {\r\n    const { context, callback, objectA, objectB } = config;\r\n    const objectsA = Array.isArray(objectA) ? objectA : [objectA];\r\n    const objectsB = Array.isArray(objectB) ? objectB : [objectB];\r\n    objectsA.forEach((a) => {\r\n      const callbacks = map.get(a) || [];\r\n      const remainingCallbacks = callbacks.filter((cb) => {\r\n        // If anything doesn't match a provided config value (i.e. anything other than undefined),\r\n        // we can bail and keep listener.\r\n        if (context !== undefined && cb.context !== context) return true;\r\n        if (callback !== undefined && cb.callback !== callback) return true;\r\n        if (objectB !== undefined && !objectsB.includes(cb.target)) return true;\r\n        return false;\r\n      });\r\n      if (remainingCallbacks.length > 0) map.set(a, remainingCallbacks);\r\n      else map.delete(a);\r\n    });\r\n  }\r\n\r\n  private addOnCollideObjectVsObject(\r\n    map: ListenerMap,\r\n    objectA: CO,\r\n    objectB: CO | undefined,\r\n    callback: CollideCallback<CO, CO>,\r\n    context: CollideContext | undefined\r\n  ) {\r\n    // Can't do anything if the first object is not defined or invalid.\r\n    if (!objectA || !isCollidingObject(objectA)) {\r\n      warnInvalidObject(objectA);\r\n      return;\r\n    }\r\n\r\n    // The second object can be undefined or a valid body.\r\n    if (objectB && !isCollidingObject(objectB)) {\r\n      warnInvalidObject(objectA);\r\n      return;\r\n    }\r\n\r\n    const callbacks = map.get(objectA) || [];\r\n    callbacks.push({ target: objectB, callback, context });\r\n    map.set(objectA, callbacks);\r\n  }\r\n\r\n  private onCollisionStart(event: MatterEvents.CollisionActiveEvent) {\r\n    this.onCollisionEvent(this.collisionStartListeners, COLLISION_START, event);\r\n  }\r\n\r\n  private onCollisionEnd(event: MatterEvents.CollisionEndEvent) {\r\n    this.onCollisionEvent(this.collisionEndListeners, COLLISION_END, event);\r\n  }\r\n\r\n  private onCollisionActive(event: MatterEvents.CollisionActiveEvent) {\r\n    this.onCollisionEvent(this.collisionActiveListeners, COLLISION_ACTIVE, event);\r\n  }\r\n\r\n  /**\r\n   * Reusable handler for collisionstart, collisionend, collisionactive.\r\n   * */\r\n  private onCollisionEvent(\r\n    listenerMap: ListenerMap,\r\n    eventName: string,\r\n    event: MatterCollisionEvent\r\n  ) {\r\n    const pairs = event.pairs as ExtendedMatterCollisionData[];\r\n    const pairEventName = \"pair\" + eventName;\r\n    const eventData: Partial<EventData<CO, CO>> = { isReversed: false };\r\n    const eventDataReversed: Partial<EventData<CO, CO>> = { isReversed: true };\r\n\r\n    pairs.map((pair, i) => {\r\n      const { bodyA, bodyB } = pair;\r\n      const rootBodyA = getRootBody(bodyA);\r\n      const rootBodyB = getRootBody(bodyB);\r\n      let gameObjectA: CO | undefined = rootBodyA.gameObject ?? undefined;\r\n      let gameObjectB: CO | undefined = rootBodyB.gameObject ?? undefined;\r\n\r\n      // Special case for tiles, where it's more useful to have a reference to the Tile object not\r\n      // the TileBody. This is hot code, so use a property check instead of instanceof.\r\n      if (gameObjectA && gameObjectA instanceof Matter.TileBody) {\r\n        gameObjectA = gameObjectA.tile;\r\n      }\r\n      if (gameObjectB && gameObjectB instanceof Matter.TileBody) {\r\n        gameObjectB = gameObjectB.tile;\r\n      }\r\n\r\n      pairs[i].gameObjectA = gameObjectA ?? undefined;\r\n      pairs[i].gameObjectB = gameObjectB ?? undefined;\r\n\r\n      eventData.bodyA = bodyA;\r\n      eventData.bodyB = bodyB;\r\n      eventData.gameObjectA = gameObjectA ?? undefined;\r\n      eventData.gameObjectB = gameObjectB ?? undefined;\r\n      eventData.pair = pair;\r\n\r\n      this.events.emit(pairEventName, eventData);\r\n\r\n      if (listenerMap.size > 0) {\r\n        eventDataReversed.bodyB = bodyA;\r\n        eventDataReversed.bodyA = bodyB;\r\n        eventDataReversed.gameObjectB = gameObjectA;\r\n        eventDataReversed.gameObjectA = gameObjectB;\r\n        eventDataReversed.pair = pair;\r\n\r\n        const data = eventData as EventData<CO, CO>;\r\n        const dataReversed = eventDataReversed as EventData<CO, CO>;\r\n\r\n        this.checkPairAndEmit(listenerMap, bodyA, bodyB, gameObjectB, data);\r\n        this.checkPairAndEmit(listenerMap, bodyB, bodyA, gameObjectA, dataReversed);\r\n\r\n        if (gameObjectA) {\r\n          this.checkPairAndEmit(listenerMap, gameObjectA, bodyB, gameObjectB, data);\r\n        }\r\n\r\n        if (gameObjectB) {\r\n          this.checkPairAndEmit(listenerMap, gameObjectB, bodyA, gameObjectA, dataReversed);\r\n        }\r\n      }\r\n    });\r\n\r\n    this.events.emit(eventName, event);\r\n  }\r\n\r\n  private checkPairAndEmit(\r\n    map: ListenerMap,\r\n    objectA: CO,\r\n    bodyB: MatterJS.Body,\r\n    gameObjectB: CO | undefined,\r\n    eventData: EventData<CO, CO>\r\n  ) {\r\n    const callbacks = map.get(objectA);\r\n    if (callbacks) {\r\n      callbacks.forEach(({ target, callback, context }) => {\r\n        if (!target || target === bodyB || target === gameObjectB) {\r\n          callback.call(context, eventData);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  subscribeMatterEvents() {\r\n    const matter = this.scene.matter;\r\n    if (!matter || !matter.world) {\r\n      logger.warn(\"Plugin requires matter!\");\r\n      return;\r\n    }\r\n    matter.world.on(COLLISION_START, this.onCollisionStart, this);\r\n    matter.world.on(COLLISION_ACTIVE, this.onCollisionActive, this);\r\n    matter.world.on(COLLISION_END, this.onCollisionEnd, this);\r\n  }\r\n\r\n  unsubscribeMatterEvents() {\r\n    // Don't unsub if matter next existing or if the game is destroyed (since the matter world will\r\n    // be already gone)\r\n    const matter = this.scene.matter;\r\n    if (!matter || !matter.world) return;\r\n    matter.world.off(COLLISION_START, this.onCollisionStart, this);\r\n    matter.world.off(COLLISION_ACTIVE, this.onCollisionActive, this);\r\n    matter.world.off(COLLISION_END, this.onCollisionEnd, this);\r\n  }\r\n\r\n  start() {\r\n    // If restarting, unsubscribe before resubscribing to ensure only one listener is added\r\n    this.scene.events.off(SHUTDOWN, this.shutdown, this);\r\n    this.scene.events.on(SHUTDOWN, this.shutdown, this);\r\n    this.subscribeMatterEvents();\r\n  }\r\n\r\n  shutdown() {\r\n    this.removeAllCollideListeners();\r\n    this.unsubscribeMatterEvents();\r\n    // Resubscribe to start so that the plugin is started again after Matter\r\n    this.scene.events.once(START, this.start, this);\r\n  }\r\n\r\n  destroy() {\r\n    this.scene.events.off(DESTROY, this.destroy, this);\r\n    this.scene.events.off(START, this.start, this);\r\n    this.scene.events.off(SHUTDOWN, this.shutdown, this);\r\n    this.removeAllCollideListeners();\r\n    this.unsubscribeMatterEvents();\r\n  }\r\n}\r\n","import PhaserMatterCollisionPlugin from \"./phaser-matter-collision-plugin\";\r\nimport { getRootBody } from \"./utils\";\r\nimport {\r\n  isCollidingObject,\r\n  isMatterBody,\r\n  ObjectWithBody,\r\n  CollidingObject,\r\n} from \"./valid-collision-object\";\r\nimport {\r\n  ExtendedMatterCollisionData,\r\n  CollisionEvent,\r\n  EventData,\r\n  CollideCallback,\r\n  CollideAConfig,\r\n  CollideABConfig,\r\n  CollideContext,\r\n  Unsubscribe,\r\n} from \"./collision-types\";\r\n\r\nexport {\r\n  PhaserMatterCollisionPlugin,\r\n  getRootBody,\r\n  isCollidingObject,\r\n  isMatterBody,\r\n  ObjectWithBody,\r\n  CollidingObject,\r\n  ExtendedMatterCollisionData,\r\n  CollisionEvent,\r\n  EventData,\r\n  CollideCallback,\r\n  CollideAConfig,\r\n  CollideABConfig,\r\n  CollideContext,\r\n  Unsubscribe,\r\n};\r\n\r\nexport default PhaserMatterCollisionPlugin;\r\n"],"sourceRoot":""}